---
title: "sorl1 4 way analysis final"
author: "Karissa"
date: "15/05/2020"
output: 
  html_document:
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---
# Packages
```{r packages, echo = T, message=FALSE}
# Set workspace -----------------------------------------------------------
library(magrittr)
library(tidyverse)
library(reshape)
library(readxl)
library(limma)
library(edgeR)
library(biomaRt)
library(AnnotationHub)
library(GenomicRanges)
library(GenomicFeatures)
library(rtracklayer)
library(fgsea)
library(RUVSeq)
library(ngsReports)
library(metap)
library(cqn)
library(harmonicmeanp)
library(ggpubr)
library(RColorBrewer)
library(grid)
library(gridExtra)
library(scales)
library(knitr)
library(kableExtra)
library(pheatmap)
library(ggrepel)
library(ggeasy)
library(ggfortify) # to allow ggplot2::autoplot() to work
library(pathview)
library(VennDiagram)
library(UpSetR)

knitr::opts_chunk$set(echo = TRUE)
```

# ~~ Introduction ~~

Here is my final (hopefully) analysis for the *sorl1* 4-way, 6 month RNA-seq experiment. This analysis investigates the effects of the mutations V1482Afs, and R122Pfs (null) in *sorl1* on 6 month old zebrafish brains. V1482Afs models the C1478* mutation in human *SORL1* which was described in *Pottier et al. (2012)*. R122Pfs is a putative null mutation which produces a premature stop codon before any of the coding sequences which encode the functional domains of the zebrafish Sorl1 protein. The family of zebrafish in this analysis arise from a pair-mating between fish of genotypes R122Pfs/+ x V1482Afs/+. Therefore, fish in the family have genotypes R122Pfs/+ (null/+), V1482Afs/+ (EOfAD-like), R122Pfs/V1482Afs (transheterozygous) and WT (non-mutant). The family was raised together in the same tanks to reduce environmental variation. Since the family contained ~100 fish, they were distributed over 3 tanks as to not stress them by overcrowding.

When the family was 6 months of age, 50 fish were sacrificed and had their brains removed. Genotyping was performed by PCR then 24 fish of equal Genotypes and sex had brain total RNA extracted and DNase I treatment. Then total RNA was sent to SAHMRI for RNA-seq (single ended, 75bp insert). The resulting fastq files were then processed using bash shell scripts to produce a counts matrix (kallisto was used to estimate transcript abundances). Kallisto settings were mean frag length = 300, sd = 60, 50 bootstraps. None of the sorl1 alternate transcripts were added to the transcriptome as sorl1 is a long gene, and kallisto couldnt tell the alternate transcripts apart, 

## Read in gr and make annotation ojects

```{r}
gr <- import.gff("ftp://ftp.ensembl.org/pub/release-96/gtf/danio_rerio/Danio_rerio.GRCz11.96.gtf.gz")

zfGeneNames <-
  gr %>% 
  mcols %>% 
  subset(type == "gene") %>% 
  as_tibble() %>% 
  dplyr::select(c(gene_id, gene_name)) 

tr2gn <- gr %>%
  subset(!is.na(transcript_id)) %>%
  subset(type == "transcript") %>%
  mcols() %>%
  as.data.frame() %>%
  dplyr::select(gene_id, transcript_id) %>%
  as_tibble()

# also need length and gc content
ah <- AnnotationHub() %>%
  subset(species == "Danio rerio") %>%
  subset(rdataclass == "EnsDb")

ensDb <- ah[["AH74989"]]

grTrans <- transcripts(ensDb)

trLengths <- exonsBy(ensDb, "tx") %>%
  width() %>%
  vapply(sum, integer(1))

mcols(grTrans)$length <- trLengths[names(grTrans)]


gcGene <- grTrans %>%
  mcols() %>%
  as.data.frame() %>%
  dplyr::select(gene_id, tx_id, gc_content, length) %>%
  as_tibble() %>%
  group_by(gene_id) %>%
  summarise(
    gc_content = sum(gc_content*length) / sum(length),
    length = ceiling(median(length))
  )

grGenes <- genes(ensDb)

mcols(grGenes) %<>%
  as.data.frame() %>%
  left_join(gcGene) %>%
  as.data.frame() %>%
  DataFrame()
```

## Metadata of samples

```{r}
meta <- read_excel("meta_4way_6m_RNA-seq.xlsx") %>% 
  dplyr::filter(!is.na(Position)) %>% 
  dplyr::select(c(Sex, Genotype, Tank, Batch_killed, RNA_Seq_id, new_sample_id)) %>% 
  mutate(
    Sex = as.factor(Sex), 
    Genotype = as.factor(Genotype), 
    Tank = as.factor(Tank),
    Batch_killed = as.factor(Batch_killed)
    ) %>% 
  mutate(
    sample = RNA_Seq_id %>% 
      str_replace_all(pattern = "_", replacement = "-"), 
    Genotype_forPub = case_when(
      Genotype == "R122Pfs/+" ~ "null/+", 
      Genotype == "trans" ~ "transhet", 
      Genotype == "V1482Afs/+" ~ "V1482Afs/+", 
      Genotype == "WT" ~ "+/+"),
      Sex = case_when(
        Sex == "male" ~ "Male", 
        Sex == "fem" ~ "Female")
    )  %>% 
  mutate(Genotype_2 = as.factor(Genotype %>% 
                                  str_remove(pattern = "/\\+")
                                )
         )
```

## Make the geneDGE and filter lowly expressed genes

Genes which are lowly expressed in RNA-seq data are not informative for differential gene expression analysis. Since one count in one RNA-seq library and 3 counts in another library does not necesserily mean a 3 fold change. Therefore we need to filter out any genes which are lowly expressed. A general rule for filtering is having a cpm above 10/(min_lib_size/1000000) in at least half of the RNA-seq libraries. (0.66 cpm). 

```{r}

# # Now can make the gene DGE object
counts <- list.files(path = here::here("kallisto_out/"), full.names = TRUE) %>%
  catchKallisto()

colnames(counts$counts) %<>%
  basename() %>%
  str_replace_all(pattern = "_S(.+)_merged_R1_001", "") %>%
  str_replace_all(pattern = "^(0|1|2).-", replacement = "") %>%
  str_replace_all(pattern = "_T1.fastq.gz", replacement = "")

geneDGE <-
  counts$counts %>%
  as.data.frame() %>%
  rownames_to_column("transcript_id") %>%
  dplyr::filter(!grepl("unspliced", transcript_id)) %>%
  as_tibble() %>%
  mutate(
    transcript_id = str_remove_all(transcript_id, "\\.[0-9]+")
    ) %>%
  gather(key = "Sample", value = "Counts", 2:25) %>%
  left_join(tr2gn) %>%
  group_by(Sample, gene_id) %>%
  summarise(Counts = sum(Counts)) %>%
  spread(key = "Sample", value = "Counts") %>%
  column_to_rownames("gene_id") %>%
  DGEList() %>%
  calcNormFactors(method = "TMM")

geneDGE$samples %<>% 
  rownames_to_column("sample") %>% 
  left_join(meta, by = "sample")

#Set the genotype WT as the reference level for DE analysis later
geneDGE$samples$Genotype <- relevel(geneDGE$samples$Genotype, "WT")

geneDGE$genes <-
  grGenes %>% 
  as_tibble() %>% 
  dplyr::select(gene_id, gene_id, gc_content, length, symbol, description) %>% 
  dplyr::filter(gene_id %in% rownames(geneDGE$counts)) %>% 
  arrange(gene_id) %>% 
  mutate(ensembl_gene_id = gene_id) %>% 
  column_to_rownames("ensembl_gene_id")

keepThesegenes <- (rowSums(cpm(geneDGE) > 0.66) >= 12) 

#before filtering
geneDGE %>% 
  cpm(log = TRUE) %>% 
  melt %>% 
  dplyr::filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = X2)) +
  geom_density() + 
  guides(colour = FALSE) +
  ggtitle("Before filtering") +
  labs(x = "logCPM", y = "Proportion of Genes") +
  theme_bw()

#after filtering
geneDGE <- geneDGE[keepThesegenes,, keep.lib.sizes=FALSE]

geneDGE %>% 
  cpm(log = TRUE) %>% 
  melt %>% 
  dplyr::filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = X2)) +
  geom_density() + 
  guides(colour = FALSE) +
  ggtitle("After filtering") +
  labs(x = "logCPM", y = "Proportion of Genes") +
  theme_bw()

```

## library sizes

```{r}
geneDGE$samples %>% 
  mutate(`Library size (millions)` = lib.size/1e6) %>% 
  ggplot(aes(new_sample_id, `Library size (millions)`, fill = Genotype_forPub)) +
  geom_col() +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("") +
  easy_rotate_labels(which = "x", angle = 315) 
```

# ~~ Principle component analysis ~~

The overall similarities between samples can be visualised by principle component analysis (PCA). Some clustering of samples is observed, *i.e the V1482Afs and R122Pfs samples. However, the WT and transhets appear to be quiet variable. 

```{r}
pca_raw <- geneDGE$counts %>% 
  cpm(log = T) %>% 
  t() %>% 
  prcomp()

pca_raw %>% 
  autoplot(
    data = tibble(sample = rownames(.$x)) %>%
      left_join(geneDGE$samples),
    colour = "Genotype_forPub", 
    shape = "Sex", 
    size = 4
  ) +
  geom_text_repel(
    aes(label = new_sample_id, colour = Genotype_forPub),
    show.legend = FALSE
  ) +
  theme_bw()
```

# ~~ DE analysis (TMM normalisation) ~~ 

Here, I will use the generalised linear model functionality of edgeR and liklihood ratio tests to look for DE genes.

Design matrix is shown below. WT is set as the intercept (i.e. the reference level). 

```{r}

design <-
  #Set the genotype WT as the reference level for DE analysis later
geneDGE$samples$Genotype <- relevel(geneDGE$samples$Genotype, "WT")

#design with WT as the intercept
design <- model.matrix(~Genotype + Sex + Tank, data = geneDGE$samples) %>% 
  set_colnames(gsub("Genotype", "", colnames(.)))
```

## fit object

The code below fits the GLM (negative binomial variance function)

```{r}
fit <- geneDGE %>% 
  estimateDisp(design) %>% 
  glmFit(design)
```

### toptables
```{r}
topTables_tmm <- design %>% colnames() %>% .[2:4] %>% 
   sapply(function(x){
    glmLRT(fit, coef = x) %>%
      topTags(n = Inf) %>%
      .[["table"]] %>%
      as_tibble() %>%
      arrange(PValue) %>%
       mutate(
        coef = x,
        DE = FDR < 0.05
      ) %>% 
      dplyr::select(
        symbol, logFC, logCPM, PValue, FDR, DE, everything()  
      )
      
  }, simplify = FALSE)
```

The scrollboxes below contain the entire toptables. Some DE genes are observed. 
```{r}
# 
# topTables_tmm$`V1482Afs/+` %>% 
#   kable(caption = "edgeR res, V1482Afs/+ vs WT comparison") %>% 
#   kable_styling(bootstrap_options = c("striped", "hover")) %>% 
#   scroll_box(width = "100%", height = "30cm")
# 
# topTables_tmm$`R122Pfs/+` %>% 
#   kable(caption = "edgeR res, null/+ vs WT comparison") %>% 
#   kable_styling(bootstrap_options = c("striped", "hover")) %>% 
#   scroll_box(width = "100%", height = "30cm")
# 
# topTables_tmm$trans %>% 
#   kable(caption = "edgeR res, transhet vs WT comparison") %>% 
#   kable_styling(bootstrap_options = c("striped", "hover")) %>% 
#   scroll_box(width = "100%", height = "30cm")
```

### Visualisation
#### MD plots

```{r}
topTables_tmm %>%
  bind_rows() %>% 
  ggplot(aes(x = logCPM, y = logFC,  colour = DE)) +
  geom_point(
    alpha = 0.5
  ) +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  geom_label_repel(
    aes(label = symbol), 
    data = .  %>% dplyr::filter(FDR < 0.05), 
    show.legend = FALSE
    ) +
  theme(legend.position = "none") +
  ggtitle("MD Plots of different sorl1 mutant comparisons to WT with TMM normalisation") +
  scale_color_manual(values = c("grey50", "red"))
```

#### Volcano plots

```{r}
topTables_tmm %>%
  bind_rows() %>% 
  ggplot(aes(y = -log10(PValue), x = logFC, colour = DE)) +
  geom_point(
    alpha = 0.5
  ) +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  geom_label_repel(
    aes(label = symbol), 
    data = .  %>% dplyr::filter(FDR < 0.05), 
    show.legend = FALSE
    ) +
  theme(legend.position = "none") +
  ggtitle("Volcano Plots of different sorl1 mutant comparisons to WT with TMM normalisation") +
  scale_color_manual(values = c("grey50", "red"))
```

## check for GC and length bias

A ranking statistic of the sign of the logFC multiplied by the log10 of the PValue was calculated for each gene. This gives a measure of the significance and also the magnitude of change for each gene. I plotted this ranking statistic against the gc content and length of each gene to see if there are any biases observed. If there was, I would use the `cqn` normalisation method to correct for this. No apparent biases were observed, therefore `cqn` is not appropriate.

```{r}
topTables_tmm %>% 
  bind_rows() %>% 
  mutate(rankstat = logFC*log10(PValue)) %>% 
  ggplot(aes(x = length, y = rankstat)) +
  geom_point(
    aes(colour = DE),
    alpha = 0.5
  ) +
  geom_smooth(se = FALSE, method = "gam") +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  theme(legend.position = "none") +
  scale_color_manual(values = c("grey50", "red")) +
  scale_x_log10()+
  scale_y_continuous(limits = c(-2.5, 2.5))
```

```{r}
topTables_tmm %>% 
  bind_rows() %>% 
  mutate(rankstat = logFC*log10(PValue)) %>% 
  ggplot(aes(x = gc_content, y = rankstat)) +
  geom_point(
    aes(colour = DE),
    alpha = 0.5
  ) +
  geom_smooth(se = FALSE, method = "gam") +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  theme(legend.position = "none") +
  scale_color_manual(values = c("grey50", "red")) +
  scale_y_continuous(limits = c(-5,5))
```

# ~~ GSEAs of TMM normalised counts ~~

To get a more complete idea of the changes to gene expression in the mutant brains, I will perform some gene set testing. Fry from the limma package, performs the fast approximation of the ROAST method. The ROAST method is a self contained gene set testing method, which tests whether any of the gene sets contains DE genes. Instead of permutation tests (like GSEA, which assumes that genes are indepenent from each other, which is not true), it performs a rotation, a Monte Carlo technology for multivariate regression and more accurately will predict whether a gene set is changed. 

Here, I will perform `FRY` on the HALLMARK and KEGG pathway gene sets which were downloaded from MSigDB (http://www.broadinstitute.org/msigdb) as a .gmt file with human entrez ids. These human entrez ids will be converted to zebrafish ensembl ids using a mapping file downloaded fro biomart. Some genes were found not to have a comlimentary zebrafish ensembl id, and this resulted in some of the KEGG pathway gene sets having only a small number of genes. Therefore, only KEGG pathway gene sets with more than 10 genes after conversion to zf ids were retained. 

## Read in gene sets 
```{r}
# need the zf2human gene mapping file from my W1818x RNA-seq analysis
zf2humangeneMapping <-  read_delim("~/Box Sync/20181113_MorganLardelli_mRNASeq-master/R/zf2human_entrez.txt",delim =  ",") %>% 
	set_colnames(c("hu_gene_id", "hu_gene_name", "Entrez", "gene_id", "gene_name"))

# import KEGG gene sets
KEGG <- gmtPathways("~/Documents/20190129_Lardelli_FMR1_RNASeq/ext_data/c2.cp.kegg.v7.1.entrez.gmt")

KEGG %<>% 	
  lapply(function(x){
    zf2humangeneMapping %>%
      dplyr::filter(Entrez %in% x, 
                    gene_id %in% rownames(geneDGE)) %>%
      .[["gene_id"]] %>% 
  		unique()
  })

KEGG_sizes <- KEGG %>% 
  lapply(length) %>% 
  unlist %>% 
  as.data.frame() %>% 
  set_colnames( "n_genes") %>% 
  rownames_to_column("pathway")

# retain gene sets with at least 10 genes in it
KEGG <- KEGG[KEGG_sizes %>% dplyr::filter(n_genes > 10) %>% .$pathway]

# Hallmark gene sets

hallmark <- gmtPathways("~/Documents/20190129_Lardelli_FMR1_RNASeq/ext_data/h.all.v7.1.entrez.gmt") %>%
  lapply(function(x){
    zf2humangeneMapping %>%
      dplyr::filter(Entrez %in% x, 
                   gene_id %in% rownames(geneDGE)) %>%
      .[["gene_id"]]
  })

hallmark_sizes <- hallmark %>% 
  lapply(length) %>% 
  unlist %>% 
  as.data.frame() %>% 
  set_colnames( "n_genes") %>% 
  rownames_to_column("pathway")

```

## fry

The code below will perform the `fry` method for each comparison. No significant gene sets were observed. 

```{r}
fryRes_TMM_kg <- 
  design %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    cpm(geneDGE$counts, log = T) %>% 
    fry(
      index = KEGG,
      design = design, 
      contrast = x, 
      sort = "directional"
    ) %>% 
    rownames_to_column("pathway") %>% 
    as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05 | FDR.Mixed < 0.05, 
             p_bonf = p.adjust(PValue, "bonf"))
  }, simplify = FALSE)

fryRes_TMM_hm <- 
  design %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    cpm(geneDGE$counts, log = T)  %>% 
    fry(
      index = hallmark,
      design = design, 
      contrast = x, 
      sort = "directional"
    ) %>% 
    rownames_to_column("pathway") %>% 
    as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05 | FDR.Mixed < 0.05, 
             p_bonf = p.adjust(PValue, "bonf"))
  }, simplify = FALSE)

fryRes_TMM_hm %>% 
  bind_rows() %>% 
  bind_rows(fryRes_TMM_kg %>% bind_rows()) %>% 
  dplyr::arrange(PValue) %>% 
  head(10) %>% 
  kable(caption = "top 10 most altered pathways. No pathways even approached being significantly altered.") %>% 
  kable_styling("basic")
```

# ~~ RUVSeq to remove unwanted variation ~~

Since the largest source of variation in this dataset appeared to be due to library size, I can use the RUV method to remove this variation. RUV has 3 methods of estimating the unwanted variation: 

• RUVg uses negative control genes, assumed to have constant expression across samples.

• RUVs uses centered (technical) replicate/negative control samples for which the covariates of interest are constant. 

• RUVr uses residuals, e.g., from a first-pass GLM regression of the counts on the covariates of interest.

Here, I will use the `RUVg` method using negative control genes, defining the 5000 least DE genes from an ANOVA-like test for differential expression using edgeR. 5000 genes are what was used in the RUVSeq vignette. 

```{r}
RUVneg <- 
  geneDGE %>% 
  estimateGLMCommonDisp(design) %>%
  estimateGLMTagwiseDisp(design) %>%
  glmFit(design) %>%
  glmLRT(coef = 2:4) %>% # use all 3 sorl1 genotype coefs
  topTags(n = Inf, adjust.method = "fdr", sort.by = "p") %>% 
  .$table %>% 
  arrange(desc(PValue)) %>% 
  .[1:5000,] %>% 
  .$gene_id
```

```{r}
### Perform the RUVg method with 1 factor of unwanted variation removed, 
RUV_k1 <- geneDGE$counts %>% 
  round %>% 
  RUVg(RUVneg, 1)
```

### PCA

PCA analysis was repeated on the RUV normalised counts. Some seperation across PC1 was observed for WT and V1482Afs/+ samples (except for sample WT-4). The null/+ samples were seperated from the V1482Afs samples, but seem to be within the WT cluster, suggesting the null samples have a similar gene expression profile to the WTs. The transhets were fairly dispersed across PC1, with transhet1 being quite distant from the rest (likely an outlier) I will retain transhet-1 at this stage. But will keep it in mind when i do the GSEAs later and look at whether it may be driving an enrichment of a gene set.

```{r}
pca_RUV_k1 <- RUV_k1$normalizedCounts %>% 
  as.data.frame() %>% 
	cpm(log = T) %>% 
	t() %>% 
	prcomp()

pca_RUV_k1 %>% 
  autoplot(
    data = tibble(sample = rownames(.$x)) %>%
      left_join(geneDGE$samples),
    colour = "Genotype_forPub", 
    shape = "Sex", 
    size = 4
  ) +
  geom_text_repel(
    aes(label = new_sample_id, colour = Genotype_forPub),
    show.legend = FALSE
  ) + 
  theme_bw() 
```


### PC1 no longer depends on library size

```{r}
pca_RUV_k1$x %>% 
  as.data.frame() %>% 
  rownames_to_column("sample") %>% 
  left_join(geneDGE$samples) %>% 
  mutate(lib.size = lib.size/1e6) %>% 
  ggplot(aes(PC1, lib.size)) +
  geom_point(
    aes(colour = Genotype_forPub), 
    size = 4
    ) +
  geom_text_repel(
    aes(label = new_sample_id, colour = Genotype_forPub), 
    show.legend = FALSE
    ) +
  theme_bw()
```

# ~~ DE analysis with RUV k1 ~~

I now will perform the DE analysis, including the W1 covariate in the model. To do this, I need to add in the W_1 value to the design matrix:

```{r}
geneDGE$samples %<>% 
  cbind(RUV_k1$W)

design_RUVk1 <- 
  model.matrix(~Genotype + Sex + Tank + W_1, data = geneDGE$samples) %>% 
  set_colnames(gsub("Genotype", "", colnames(.)))
```

## repeat the fit and toptables

```{r}
fit_RUVk1 <- geneDGE %>% 
  estimateDisp(design_RUVk1) %>% 
  glmFit(design_RUVk1)
```

### toptables
```{r}
topTables_RUVk1 <- design_RUVk1 %>% colnames() %>% .[2:4] %>% 
   sapply(function(x){
    glmLRT(fit_RUVk1, coef = x) %>%
      topTags(n = Inf) %>%
      .[["table"]] %>%
      as_tibble() %>%
      arrange(PValue) %>%
       mutate(
        coef = x,
        DE = FDR < 0.05
      ) %>% 
      dplyr::select(
        symbol, logFC, logCPM, PValue, FDR, DE, everything()  
      )
      
  }, simplify = FALSE)

# # Make a copy of the Toptables for export
# topTables_RUVk1_forExport <- topTables_RUVk1
# 
# # Change the names so that it can be written out
# names(topTables_RUVk1_forExport) <- c("Null", "V1482Afs", "transhet")
# 
# writexl::write_xlsx(topTables_RUVk1_forExport, path = "DE_Res/Differential_Expression_Results_RUV_k1.xlsx")
# 
# # Remove the copy
# remove(topTables_RUVk1_forExport)
```

The scrollboxes below contain the entire toptables. DE genes are observed in each comparison

```{r}
# topTables_RUVk1$`V1482Afs/+` %>% 
#   kable(caption = "edgeR res, V1482Afs/+ vs WT comparison") %>% 
#   kable_styling(bootstrap_options = c("striped", "hover")) %>% 
#   scroll_box(width = "100%", height = "30cm")
# 
# topTables_RUVk1$`R122Pfs/+` %>% 
#   kable(caption = "edgeR res, null/+ vs WT comparison") %>% 
#   kable_styling(bootstrap_options = c("striped", "hover")) %>% 
#   scroll_box(width = "100%", height = "30cm")
# 
# topTables_RUVk1$trans %>% 
#   kable(caption = "edgeR res, transhet vs WT comparison") %>% 
#   kable_styling(bootstrap_options = c("striped", "hover")) %>% 
#   scroll_box(width = "100%", height = "30cm")
```

### Visualisation
#### MD plots

```{r}
topTables_RUVk1 %>%
  bind_rows() %>% 
  ggplot(aes(x = logCPM, y = logFC,  colour = DE)) +
  geom_point(
    alpha = 0.5
  ) +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  geom_label_repel(
    aes(label = symbol), 
    data = .  %>% dplyr::filter(FDR < 0.05), 
    show.legend = FALSE
    ) +
  theme(legend.position = "none") +
  ggtitle("MD Plots of different sorl1 mutant comparisons to WT with RUV k=1") +
  scale_color_manual(values = c("grey50", "red"))
```

#### Volcano plots

```{r}
topTables_RUVk1 %>%
  bind_rows() %>% 
  ggplot(aes(y = -log10(PValue), x = logFC, colour = DE)) +
  geom_point(
    alpha = 0.5
  ) +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  geom_label_repel(
    aes(label = symbol), 
    data = .  %>% dplyr::filter(FDR < 0.05), 
    show.legend = FALSE
    ) +
  theme(legend.position = "none") +
  ggtitle("Volcano Plots of different sorl1 mutant comparisons to WT with RUV (k = 1)") +
  scale_color_manual(values = c("grey50", "red"))
```

Many more genes were detected as DE now for the sorl1 null/+ and transhet samples. Statistical evidence was only observed for one DE gene in the EOfAD-like V1482Afs/+ mutant brains, cox7a1, a gene involved in the electron transport chain. 

## check for GC and length bias

Next, I will check whether there have been any GC or length biases introduced due to RUVSeq. I generated below the same kind of plots I did earlier in this analysis. No bias's appear to be introduced as each of the "fit" lines are straight along 0. Note that these graphs are zoomed in so I can see whether there are any weak biases. 

No biases were observed still. Which is good. 

```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  mutate(rankstat = logFC*log10(PValue)) %>% 
  ggplot(aes(x = length, y = rankstat)) +
  geom_point(
    aes(colour = DE),
    alpha = 0.5
  ) +
  geom_smooth(se = FALSE, method = "gam") +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  theme(legend.position = "none") +
  scale_color_manual(values = c("grey50", "red")) +
  scale_x_log10()+
  scale_y_continuous(limits = c(-2.5, 2.5))
```

```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  mutate(rankstat = logFC*log10(PValue)) %>% 
  ggplot(aes(x = gc_content, y = rankstat)) +
  geom_point(
    aes(colour = DE),
    alpha = 0.5
  ) +
  geom_smooth(se = FALSE, method = "gam") +
  facet_grid(rows = vars(coef)) +
  theme_bw() +
  theme(legend.position = "none") +
  scale_color_manual(values = c("grey50", "red")) +
  scale_y_continuous(limits = c(-5,5))
```

# ~~ GSEAs with RUV (k = 1) ~~

Next, I want to see if as a *group*, genes tend to show significant changes. 

## fry

```{r}
fryRes_RUVk1_kg <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = TRUE) %>% 
      fry(
        index = KEGG,
        design = design_RUVk1, 
        contrast = x, 
        sort = "directional"
      ) %>% 
      rownames_to_column("pathway") %>% 
      as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05 | FDR.Mixed < 0.05, 
             p_bonf = p.adjust(PValue, "bonf"))
  }, simplify = FALSE)

fryRes_RUVk1_hm <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = TRUE) %>% 
      fry(
        index = hallmark,
        design = design_RUVk1, 
        contrast = x, 
        sort = "directional"
      ) %>% 
      rownames_to_column("pathway") %>% 
      as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05 | FDR.Mixed < 0.05, 
             p_bonf = p.adjust(PValue, "bonf"))
  }, simplify = FALSE)

fryRes_RUVk1_hm %>% 
  bind_rows() %>% 
  bind_rows(fryRes_RUVk1_kg %>% bind_rows()) %>% 
  dplyr::filter(FDR < 0.05 | FDR.Mixed < 0.05) %>% 
  kable() %>% 
  kable_styling("basic")
```

Still no significant pathways are observed. So I will try the "ensemble" method of GSEA, by performing 3 different methods of GSEA and combining raw p values by calculating their harmonic mean. 

## camera

CAMERA (Correlation Adjusted MEan RAnk) is a competitive gene set test which accounts for inter-gene correlation. It tests whether the genes in the set are highly ranked in terms of differential expression relative to genes not in the set. 

No gene sets were signifcantly altered in this gene set test. Some of the top gene sets are shown below. 

```{r}
camera_res_KEGG_RUVk1 <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = TRUE) %>% 
      camera(
        index = KEGG,
        design = design_RUVk1, 
        contrast = x, 
        inter.gene.cor = NA, 
        sort = TRUE
      ) %>% 
      rownames_to_column("pathway") %>% 
      as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05)
  }, simplify = FALSE)

camera_res_hm_RUVk1 <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = TRUE) %>% 
      camera(
        index = hallmark,
        design = design_RUVk1, 
        contrast = x, 
        inter.gene.cor = NA, 
        sort = TRUE
      ) %>% 
      rownames_to_column("pathway") %>% 
      as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05)
  }, simplify = FALSE)

camera_res_KEGG_RUVk1 %>% 
  bind_rows() %>% 
  bind_rows(camera_res_hm_RUVk1 %>% bind_rows()) %>% 
  arrange(PValue) %>% 
  head(10) %>% 
  kable(caption = "Top 10 DE pathways using the camera algorithm") %>% 
  kable_styling() 
```

## fgsea

Finally I will look at fgsea, This is the fast implementation of GSEA. All genes are ranked by differential expression (sign(logFC) x log10(PValue)), resulting in a ranked list starting from the most upregulated genes, ending in the most downregulated genes, and unchanged genes in the middle. The fgsea uses a Kolmogorov–Smirnov-like statistc called an enrichment score (ES), that represents the amount to which  genes in a predefined geneset are overrepresented at either the start or end of the ranked list. fgsea then estimates the statistical significance of the ES. This calculation is done by a (sample or gene) permutation test in order to produce a null distribution for the ES. The P value is determined by comparison to the null distribution. 
Note that fgsea is quite naive in that it does not account for inter-gene correlation, therefore it will likely show false positives due to the nature of the permutations it performs. 

```{r}
# create a rank stat for fgsea
ranks_fgseaRUVk1 <- 
   sapply(topTables_RUVk1, function(x) {
     x %>% 
       mutate(PValue_withsign = sign(logFC) * log10(1/PValue)) %>% 
       arrange(PValue_withsign) %>% 
       dplyr::select(c("gene_id", "PValue_withsign")) %>% #only want the Pvalue with sign
       with(structure(PValue_withsign, names = gene_id)) %>% 
       rev() # reverse so the start of the list is upregulated genes
   }, simplify = FALSE)

# Run fgsea
# This takes a while due to the number of permutations
# set a seed for a reproducible result
set.seed(33)
fgseaRes_RUVk1_kg <- ranks_fgseaRUVk1 %>%
  lapply(function(x){
    fgsea(stats = x, pathways = KEGG, nproc = 1, nperm = 1e6) %>%
      as_tibble() %>%
      dplyr::rename(FDR = padj) %>%
      mutate(padj = p.adjust(pval, "bonferroni")) %>%
      dplyr::select(pathway, pval, FDR, padj, everything()) %>%
      arrange(pval) %>%
      mutate(sig = padj < 0.05)
  })

fgseaRes_RUVk1_kg$`R122Pfs/+` %<>% 
  mutate(coef = "R122Pfs/+")

fgseaRes_RUVk1_kg$trans %<>% 
  mutate(coef = "trans")

fgseaRes_RUVk1_kg$`V1482Afs/+` %<>% 
  mutate(coef = "V1482Afs/+")

# Run fgsea
# This takes a while due to the number of permutations
set.seed(33)
fgseaRes_RUVk1_hm <- ranks_fgseaRUVk1 %>%
  lapply(function(x){
    fgsea(stats = x, pathways = hallmark, nproc = 1, nperm = 1e6) %>%
      as_tibble() %>%
      dplyr::rename(FDR = padj) %>%
      mutate(padj = p.adjust(pval, "bonferroni")) %>%
      dplyr::select(pathway, pval, FDR, padj, everything()) %>%
      arrange(pval) %>%
      mutate(sig = padj < 0.05)
  })

fgseaRes_RUVk1_hm$`R122Pfs/+` %<>% 
  mutate(coef = "R122Pfs/+")

fgseaRes_RUVk1_hm$trans %<>% 
  mutate(coef = "trans")

fgseaRes_RUVk1_hm$`V1482Afs/+` %<>% 
  mutate(coef = "V1482Afs/+")

fgseaRes_RUVk1_hm %>% 
  bind_rows() %>% 
  bind_rows(fgseaRes_RUVk1_kg %>% 
              bind_rows()) %>% 
  dplyr::filter(sig == T) %>% 
  dplyr::select(-leadingEdge) %>% 
  kable(caption = "Significant KEGG & HALLMARK gene sets using the fgsea algorithm. Gene sets were considered signiicant if they had a Bonferroni-adjusted p value of < 0.05.") %>% 
  kable_styling()
```

## harmonic p value

Significant gene sets were only observed in the transhet for fry (probably the most correct method with the best power). Some siginicant gene sets were observed for the V1482Afs and null samples in the fgsea algorithm after bonferroni adjustment (which is a very strict threshold), so there may be something there. 

Next, i will perform a meta analysis of the gseas by calculating the harmonic mean p value. This method corrects for the strong-sense family-wise error rate, and states whether groups of *dependent* p values are statistically significant. 


```{r}
harmonicPvals_hm <- 
  fryRes_RUVk1_hm %>% 
  bind_rows() %>% 
  dplyr::select(pathway, PValue.Mixed, coef) %>% 
  dplyr::rename(fry_p = PValue.Mixed) %>% 
  left_join(camera_res_hm_RUVk1 %>% 
              bind_rows() %>% 
              dplyr::select(pathway, PValue, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(camera_p = PValue) %>% 
  left_join(fgseaRes_RUVk1_hm %>% 
              bind_rows() %>% 
              dplyr::select(pathway, pval, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(fgsea_p = pval) %>% 
  bind_rows() %>% 
  nest(p = one_of(c("fry_p", "camera_p", "fgsea_p"))) %>% 
  mutate(
    harmonic_p = vapply(p, function(x){
      x <- unlist(x)
      x <- x[!is.na(x)]
      p.hmp(x, L = 3)
    }, numeric(1))
  ) %>% 
  unnest() %>% 
  mutate(harmonic_p_FDR = p.adjust(harmonic_p, "fdr"), 
         sig = harmonic_p_FDR < 0.05) %>% 
  arrange(harmonic_p_FDR)

harmonicPvals_kg <- 
  fryRes_RUVk1_kg%>% 
  bind_rows() %>% 
  dplyr::select(pathway, PValue.Mixed, coef) %>% 
  dplyr::rename(fry_p = PValue.Mixed) %>% 
  left_join(camera_res_KEGG_RUVk1 %>% 
              bind_rows() %>% 
              dplyr::select(pathway, PValue, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(camera_p = PValue) %>% 
  left_join(fgseaRes_RUVk1_kg %>% 
              bind_rows() %>% 
              dplyr::select(pathway, pval, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(fgsea_p = pval) %>% 
  bind_rows() %>% 
  nest(p = one_of(c("fry_p", "camera_p", "fgsea_p"))) %>% 
  mutate(
    harmonic_p = vapply(p, function(x){
      x <- unlist(x)
      x <- x[!is.na(x)]
      p.hmp(x, L = 3)
    }, numeric(1))
  ) %>% 
  unnest() %>% 
  mutate(harmonic_p_FDR = p.adjust(harmonic_p, "fdr"), 
         sig = harmonic_p_FDR < 0.05) %>% 
  arrange(harmonic_p_FDR)

harmonicPvals_hm %>% 
  bind_rows(harmonicPvals_kg) %>% 
  dplyr::filter(sig == TRUE & coef == "V1482Afs/+") %>% 
  kable(caption = "Significant gene sets in V1482Afs/+ brains (harmonic mean p FDR adjusted < 0.05)") %>% 
  kable_styling()

harmonicPvals_hm %>% 
  bind_rows(harmonicPvals_kg) %>% 
  dplyr::filter(sig == TRUE & coef == "R122Pfs/+") %>% 
  kable(caption = "Significant gene sets in null/+ brains (harmonic mean p FDR adjusted < 0.05)") %>% 
  kable_styling()

harmonicPvals_hm %>% 
  bind_rows(harmonicPvals_kg) %>% 
  dplyr::filter(sig == TRUE & coef == "trans") %>% 
  kable(caption = "Significant gene sets in trans brains (harmonic mean p FDR adjusted < 0.05)") %>% 
  kable_styling()
```

## Visualisation

### dotplot summary
```{r}
sigpaths <- 
  harmonicPvals_hm %>% 
  bind_rows(harmonicPvals_kg %>% bind_rows()) %>% 
  dplyr::filter(harmonic_p_FDR < 0.05) %>% 
  .$pathway

harmonicPvals_hm %>% 
  bind_rows(harmonicPvals_kg %>% bind_rows()) %>% 
  dplyr::filter(pathway %in% sigpaths) %>% 
  ggplot(aes(coef, pathway, size =-log10(harmonic_p))) +
  geom_point(aes(colour = sig)) +
  geom_text(
    aes(label = harmonic_p_FDR %>% signif(1)), 
    size = 2.5, 
    vjust = 2.5
  ) +
  labs(colour = "harmonic mean p < 0.05 \nafter FDR adjustment")+
  ggpubr::theme_pubclean()+
  theme(legend.position = "right")+
  easy_rotate_labels(which = "x", angle =315) +
  scale_color_manual(values = c("grey30", "turquoise3")) +
  ggsave("plots/dotplot_RUVk1_HMandKG_harmonicP.png", width = 20, height = 30, units = "cm", dpi = 300)

sig_in <- harmonicPvals_hm %>%
  bind_rows(harmonicPvals_kg %>% bind_rows()) %>%
  dplyr::filter(pathway %in% sigpaths) %>%
  dplyr::select(pathway, harmonic_p_FDR, coef) %>%
  spread(key = "coef", value = "harmonic_p_FDR") %>%
  mutate(sig_in = case_when(
    `R122Pfs/+` < 0.05 & trans < 0.05 & `V1482Afs/+` < 0.05 ~ "all",
    `R122Pfs/+` > 0.05 & trans < 0.05 & `V1482Afs/+` < 0.05 ~ "trans&EOfAD",
    `R122Pfs/+` < 0.05 & trans > 0.05 & `V1482Afs/+` < 0.05 ~ "null&EOfAD",
    `R122Pfs/+` < 0.05 & trans < 0.05 & `V1482Afs/+` > 0.05 ~ "null&trans",
    `R122Pfs/+` < 0.05 & trans > 0.05 & `V1482Afs/+` > 0.05 ~ "null only",
    `R122Pfs/+` > 0.05 & trans < 0.05 & `V1482Afs/+` > 0.05 ~ "transOnly",
    `R122Pfs/+` > 0.05 & trans > 0.05 & `V1482Afs/+` < 0.05 ~ "eofAD only",
  )) %>%
  dplyr::select(pathway, sig_in)

harmonicPvals_hm %>%
  bind_rows(harmonicPvals_kg %>% bind_rows()) %>%
  dplyr::filter(pathway %in% sigpaths) %>%
  left_join(sig_in) %>%
  ggplot(aes(coef, pathway, size =-log10(harmonic_p))) +
  geom_point(aes(colour = sig)) +
  geom_text(
    aes(label = harmonic_p_FDR %>% signif(1)),
    size = 2.5,
    vjust = 2.5
  ) +
  labs(colour = "harmonic mean p < 0.05 \nafter FDR adjustment")+
  ggpubr::theme_pubclean()+
  theme(legend.position = "right")+
  easy_rotate_labels(which = "x", angle =315) +
  facet_wrap(~sig_in, scales = "free", strip.position = "right") +
  scale_color_manual(values = c("grey30", "turquoise3")) +
  ggsave("plots/dotplotbySignifin.png", width = 40, units = "cm")
```

### pheatmaps
```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% hallmark$HALLMARK_OXIDATIVE_PHOSPHORYLATION) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    clustering_method = "average",
    cutree_rows = 5,
    height = 6,
    width = 3,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
```

```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% KEGG$KEGG_RIBOSOME) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    clustering_method = "average",
    cutree_rows = 5,
    height = 6,
    width = 3,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
```

```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% hallmark$HALLMARK_MTORC1_SIGNALING) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    clustering_method = "ward",
    cutree_rows = 5,
    height = 6,
    width = 3,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"PiYG")))(100)
  )
```



# ~~ GSEA IRE with RUV k = 1 ~~ 

Nhi Hin, a PhD candidate in our lab, recently developed a method for testing for iron dyshomeostasis in RNA-seq data. (see https://www.biorxiv.org/content/10.1101/2020.05.01.071498v2 for the preprint article). I will use a modified version of this analysis, where i will use the RUV adjusted counts as input rather than a *limma voom* object as input for the GSEAs on the IRE gene sets. Also, rather than combining the raw p-values using Wilkinsons method (which assumes that each p value from each of the methods of GSEA are independent), i will use the harmonic mean p method, which does not have this assumption. 

fry, camera, mroast and fgsea are the GSEA algorithms,

## import the gene sets

```{r}
zebrafishIreGenes <- readRDS("~/Box Sync/SORL1 Project/4way_RNA_seq_6m/iron_enrichment/Res from Nhi/zebrafishIreGenes.rds")
```

## GSEAs

### fry
```{r}
fry_ire_RUVk1 <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = T) %>% 
      fry(
        index = zebrafishIreGenes,
        design = design_RUVk1, 
        contrast = x, 
        sort = "directional"
      ) %>% 
      rownames_to_column("pathway") %>% 
      as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05)
  }, simplify = FALSE)
```

### camera
```{r}
camera_ire_RUV <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = T) %>% 
    camera(
      index = zebrafishIreGenes,
      design = design_RUVk1, 
      contrast = x, 
      inter.gene.cor = NA, 
      sort = TRUE
    ) %>% 
    rownames_to_column("pathway") %>% 
    as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05)
  }, simplify = FALSE)
```

### mroast

```{r}
mroast_ire_RUV <- 
  design_RUVk1 %>% colnames() %>% .[2:4] %>% 
  sapply(function(x) {
    RUV_k1$normalizedCounts %>% 
      cpm(log = T) %>% 
      mroast(
        index = zebrafishIreGenes,
        design = design_RUVk1, 
        contrast = x, 
      ) %>% 
      rownames_to_column("pathway") %>% 
      as_tibble() %>% 
      mutate(coef = x, 
             sig = FDR < 0.05)
  }, simplify = FALSE)
```

### fgsea
```{r}
# Run fgsea
fgseaRes_ire_RUV <- ranks_fgseaRUVk1 %>% 
  lapply(function(x){
    fgsea(stats = x, 
          pathways = zebrafishIreGenes, 
          nperm = 1e6, 
          nproc = 1) %>% 
      as_tibble() %>%
      dplyr::rename(FDR = padj) %>%
      mutate(padj = p.adjust(pval, "bonferroni")) %>%
      dplyr::select(pathway, pval, FDR, padj, everything()) %>%
      arrange(pval) %>%
      mutate(sig = padj < 0.05)
  })

fgseaRes_ire_RUV$`R122Pfs/+` %<>% 
  mutate(coef = "R122Pfs/+")

fgseaRes_ire_RUV$trans %<>% 
  mutate(coef = "trans")

fgseaRes_ire_RUV$`V1482Afs/+` %<>% 
  mutate(coef = "V1482Afs/+")
```

### harmonic p
```{r}
harmonic_p_ire_RUV <- 
  fry_ire_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::select(pathway, PValue.Mixed, coef) %>% 
  dplyr::rename(fry_p = PValue.Mixed) %>% 
  left_join(camera_ire_RUV %>% 
              bind_rows() %>% 
              dplyr::select(pathway, PValue, coef), 
            by = c("pathway", "coef")) %>% 
  dplyr::rename(camera_p = PValue) %>% 
  left_join(fgseaRes_ire_RUV %>% 
              bind_rows() %>% 
              dplyr::select(pathway, pval, coef), 
            by = c("pathway", "coef")
            ) %>% 
  dplyr::rename(fgsea_p = pval) %>% 
  left_join(
    mroast_ire_RUV %>% 
      bind_rows() %>% 
      dplyr::select(pathway, PValue, coef), 
    by = c("pathway", "coef")) %>% 
  dplyr::rename(mroast_p = PValue) %>% 
  bind_rows() %>% 
  nest(p = one_of(c("fry_p", "camera_p", "fgsea_p", "mroast_p"))) %>% 
 mutate(harmonic_p = vapply(p, function(x){
        x <- unlist(x)
        x <- x[!is.na(x)]
        p.hmp(x, L = 4)
      }, numeric(1))
    ) %>% 
  unnest() %>% 
  mutate(harmonic_p_FDR = p.adjust(harmonic_p, "fdr"), 
         sig = harmonic_p_FDR < 0.05) %>% 
  arrange(harmonic_p_FDR) 
```

```{r}
harmonic_p_ire_RUV %>% 
  mutate(
    pathway = case_when(
      pathway == "ire5_hq" ~ "Canonical 5' IRE", 
      pathway == "ire5_all" ~ "All predicted 5' IRE", 
      pathway == "ire3_hq" ~ "Canonical 3' IRE", 
      pathway == "ire3_all" ~ "All predicted 3' IRE"
    )
  ) %>% 
  ggplot(aes(pathway, -log10(harmonic_p), fill = sig)) +
  geom_col() +
  facet_wrap(~coef) +
  coord_flip() +
  xlab("") +
  theme_bw()
```

```{r}
RUV_k1$normalizedCounts %>% 
  cpm(log = T) %>% 
  as.data.frame() %>% 
  .[zebrafishIreGenes$ire3_hq,] %>% 
  na.omit() %>% 
  rownames_to_column("gene_id") %>% 
  gather(key = "sample", value = "logCPM", colnames(geneDGE)) %>% 
  left_join(geneDGE$samples) %>% 
  left_join(geneDGE$genes, by = "gene_id") %>% 
  dplyr::select(symbol, new_sample_id, logCPM) %>% 
  spread(key = "new_sample_id", value = "logCPM") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    cluster_cols = F, 
    gaps_col = c(4,10,16),
    border_color = NA,
    scale = "row",
    color = viridis_pal(option = "plasma")(100)
  )
```

```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% zebrafishIreGenes$ire3_hq) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "Canonical IRE 3'",
    fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100)
  )
```

```{r}
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% zebrafishIreGenes$ire3_all) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "All predicted IRE 3'",
    fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100)
  )
```

# ~~ plots for publication ~~

## DE analysis

```{r}
ggarrange(
  topTables_RUVk1 %>%
    bind_rows() %>% 
    ggplot(aes(x = logCPM, y = logFC,  colour = DE)) +
    geom_point(
      alpha = 0.25
    ) +
    facet_grid(rows = vars(coef)) +
    theme_bw() +
    # geom_label_repel(
    #   aes(label = symbol), 
    #   data = .  %>% dplyr::filter(FDR < 0.05), 
    #   show.legend = FALSE, 
    #   size = 2.5
    # ) +
    theme(legend.position = "none") +
    scale_color_manual(values = c("grey50", "red")),
  
  topTables_RUVk1 %>%
    bind_rows() %>% 
    ggplot(aes(y = -log10(PValue), x = logFC, colour = DE)) +
    geom_point(
      alpha = 0.25
    ) +
    facet_grid(rows = vars(coef)) +
    theme_bw() +
    # geom_label_repel(
    #   aes(label = symbol), 
    #   size = 2.5,
    #   data = .  %>% dplyr::filter(FDR < 0.05), 
    #   show.legend = FALSE
    # ) +
    theme(legend.position = "none") +
    scale_color_manual(values = c("grey50", "red")), 
  labels = c("B", "C"), 
  legend = "bottom", 
  common.legend = TRUE
) +
  ggsave("plots/volcano_MD_noLabs.png", width = 17, height = 15, units = "cm", dpi = 300)
```

## venn diagram
```{r}

venn.diagram(
  list(`null/+` = topTables_RUVk1$`R122Pfs/+` %>% 
         dplyr::filter(DE == T) %>% 
         .$gene_id, 
       `V1482Afs/+`= topTables_RUVk1$`V1482Afs/+` %>% 
         dplyr::filter(DE == T) %>% 
         .$gene_id, 
       trans = topTables_RUVk1$trans %>% 
         dplyr::filter(DE == T) %>% 
         .$gene_id), 
  filename = "plots/venn_DE_genes.png", 
  fill = c("#7CAE00", "#C77CFF", "#00BFC4"),
  main.fontfamily = "Arial", 
  alpha = 0.5, 
  cat.cex = 2.5
) 
```

# pathview
## OXPHOS
```{r}
pathview(
  species = "dre", 
  pathway.id = "dre00190", 
  gene.data = topTables_RUVk1$`R122Pfs/+` %>% 
    dplyr::select(gene_id, logFC) %>% 
    column_to_rownames("gene_id"), 
  gene.idtype = "ENSEMBL", 
  limit = list(gene = 0.3, 
               cpd = 0.3), 
  low = list(gene = "#2166AC", 
             cpd = "white"),
  high = list(gene = "#B2182B", 
              cpd = "white"),
  bins = list(gene = 20, 
              cpd = 20), 
  out.suffix = "null_oxphos"
         )

pathview(
  species = "dre", 
  pathway.id = "dre00190", 
  gene.data = topTables_RUVk1$`V1482Afs/+` %>% 
    dplyr::select(gene_id, logFC) %>% 
    column_to_rownames("gene_id"), 
  gene.idtype = "ENSEMBL", 
  limit = list(gene = 0.3, 
               cpd = 0.3), 
  low = list(gene = "#2166AC", 
             cpd = "white"),
  high = list(gene = "#B2182B", 
              cpd = "white"),
  bins = list(gene = 20, 
              cpd = 20), 
  out.suffix = "eofad_oxphos"
         )

pathview(
  species = "dre", 
  pathway.id = "dre00190", 
  gene.data = topTables_RUVk1$trans %>% 
    dplyr::select(gene_id, logFC) %>% 
    column_to_rownames("gene_id"), 
  gene.idtype = "ENSEMBL", 
  limit = list(gene = 0.3, 
               cpd = 0.3), 
  low = list(gene = "#2166AC", 
             cpd = "white"),
  high = list(gene = "#B2182B", 
              cpd = "white"),
  bins = list(gene = 20, 
              cpd = 20), 
  out.suffix = "trans_oxphos"
         )
```

# Upset plot of the leading edge of the significant pathways

## V1482Afs
```{r}
upsetInput_V1482Afs <- fgseaRes_RUVk1_kg$`V1482Afs/+` %>% 
  bind_rows(fgseaRes_RUVk1_hm$`V1482Afs/+`) %>% 
  dplyr::filter(pathway %in% c(harmonicPvals_hm %>% 
                                 bind_rows(harmonicPvals_kg) %>% 
                                 dplyr::filter(coef == "V1482Afs/+" & sig == TRUE) %>% 
                                 .$pathway)) %>% 
  dplyr::select(pathway, leadingEdge) %>% 
  unnest %>% 
  split(f = .$pathway) %>% 
  lapply(magrittr::extract2,"leadingEdge")

png("plots/upset/leadingEdgeV1482Afs.png", 
    width = 20, height = 20, units = "cm", res = 200)
upset(data = fromList(upsetInput_V1482Afs), 
     nsets = length(upsetInput_V1482Afs), 
    order.by = "freq", 
    point.size = 2,
    mb.ratio = c(0.4, 0.6), 
    line.size = 1,
    set_size.numbers_size = 2, 
    set_size.angles = 45)
dev.off()
```

## null
```{r}
upsetInput_null <- fgseaRes_RUVk1_kg$`R122Pfs/+` %>% 
  bind_rows(fgseaRes_RUVk1_hm$`R122Pfs/+`) %>% 
  dplyr::filter(pathway %in% c(harmonicPvals_hm %>% 
                                 bind_rows(harmonicPvals_kg) %>% 
                                 dplyr::filter(coef == "R122Pfs/+" & sig == TRUE) %>% 
                                 .$pathway)) %>% 
  dplyr::select(pathway, leadingEdge) %>% 
  unnest %>% 
  split(f = .$pathway) %>% 
  lapply(magrittr::extract2,"leadingEdge")

png("plots/upset/leadingEdgenull.png", 
    width = 20, height = 20, units = "cm", res = 200)
  upset(data = fromList(upsetInput_null), 
     nsets = length(upsetInput_null), 
    order.by = "freq", 
    point.size = 2,
    mb.ratio = c(0.4, 0.6), 
    line.size = 1,
    set_size.numbers_size = 2, 
    set_size.angles = 45)
dev.off()
```

## trans
```{r}
upsetInput_trans <- fgseaRes_RUVk1_kg$trans %>% 
  bind_rows(fgseaRes_RUVk1_hm$trans) %>% 
  dplyr::filter(pathway %in% c(harmonicPvals_hm %>% 
                                 bind_rows(harmonicPvals_kg) %>% 
                                 dplyr::filter(coef == "trans" & sig == TRUE) %>% 
                                 .$pathway)) %>% 
  dplyr::select(pathway, leadingEdge) %>% 
  unnest %>% 
  split(f = .$pathway) %>% 
  lapply(magrittr::extract2,"leadingEdge")

png("plots/upset/leadingEdgetrans.png", 
    width = 20, height = 20, units = "cm", res = 200)
upset(data = fromList(upsetInput_trans), 
     nsets = length(upsetInput_trans), 
    order.by = "freq", 
    point.size = 2,
    mb.ratio = c(0.4, 0.6), 
    line.size = 1,
    set_size.numbers_size = 2, 
    set_size.angles = 45)
dev.off()
```

# pheatmaps showing different directions

```{r}
png("plots/heatmaps/kegg_ad_logFC.png", width = 5, height = 7, units = "cm", res = 300)
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% KEGG$KEGG_ALZHEIMERS_DISEASE) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "KEGG_ALZHEIMERS_DISEASE",fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
dev.off()
```

```{r}
png("plots/heatmaps/KEGG_OXIDATIVE_PHOSPHORYLATIONlogFC.png", width = 5, height = 7, units = "cm", res = 300)
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% KEGG$KEGG_OXIDATIVE_PHOSPHORYLATION) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "KEGG_OXIDATIVE_PHOSPHORYLATION",
    fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
dev.off()
```

```{r}
png("plots/heatmaps/KEGG_CITRATE_CYCLE_TCA_CYCLE_logFC.png", width = 5, height = 7, units = "cm", res = 300)
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% KEGG$KEGG_CITRATE_CYCLE_TCA_CYCLE) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "KEGG_CITRATE_CYCLE_TCA_CYCLE",
    fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
dev.off()
```

```{r}
png("plots/heatmaps/HALLMARK_BILE_ACID_METABOLISM_logFC.png", width = 5, height = 7, units = "cm", res = 300)
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% hallmark$HALLMARK_BILE_ACID_METABOLISM) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  dplyr::distinct(symbol, coef, .keep_all = TRUE) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "HALLMARK_BILE_ACID_METABOLISM",
    fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
dev.off()
```

```{r}
png("plots/heatmaps/HALLMARK_ALLOGRAFT_REJECTION_logFC.png", width = 5, height = 7, units = "cm", res = 300)
topTables_RUVk1 %>% 
  bind_rows() %>% 
  dplyr::filter(gene_id %in% hallmark$HALLMARK_ALLOGRAFT_REJECTION) %>% 
  dplyr::select(symbol, logFC, coef) %>% 
  dplyr::distinct(symbol, coef, .keep_all = TRUE) %>% 
  spread(key = "coef", value = "logFC") %>% 
  column_to_rownames("symbol") %>% 
  pheatmap(
    border_color = NA,
    scale = "row",
    height = 5,
    main = "HALLMARK_ALLOGRAFT_REJECTION",
    fontsize = 8, 
    width = 3,
    cellwidth = 10, 
    treeheight_col = 2,
    treeheight_row = 15,
    show_rownames = FALSE,
    color = colorRampPalette(rev(brewer.pal(n = 7, name =
"RdBu")))(100)
  )
dev.off()
```



  




